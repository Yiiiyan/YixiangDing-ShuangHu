package edu.usc.softarch.arcade.util.WsVulnerabilityAnalyser;

import java.io.File;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

public class VulnerabilityAnalyser {
    // Singleton with lazy initialization
    private static VulnerabilityAnalyser analyser = null;

    private Map<File, Integer> candidateFiles;
    private Pattern importPattern;

    private int policyMask;

    public static VulnerabilityAnalyser getInstance() {
        if (analyser == null) {
            analyser = new VulnerabilityAnalyser();
        }
        return analyser;
    }

    private VulnerabilityAnalyser() {
        candidateFiles = new HashMap<>();
        importPattern = Pattern.compile("^import .*websocket.*Endpoint;$", Pattern.CASE_INSENSITIVE);
        policyMask = 0;
    }


    public void analyzeFileByLine(File file, String line) {
        if (!shouldAddFileAsCandidate(line, file)) {
            return;
        }

        if(!candidateFiles.containsKey(file)) {
            candidateFiles.put(file, Policies.SECURED_ENDPOINT_POLICY);
        }

        if (!isTestFile(file)) {
            candidateFiles.put(file, candidateFiles.get(file) | Policies.NO_TEST_FILE_POLICY);
        }

        if (isEndpointSecured(line, file)) {
            candidateFiles.put(file, candidateFiles.get(file) ^ Policies.SECURED_ENDPOINT_POLICY);
        }

        if (isSSLConfigurationSecured(line, file)) {
            candidateFiles.put(file, candidateFiles.get(file) | Policies.SECURED_SSL_CONFIGURATION_POLICY);
        }
    }

    private boolean isTestFile(File file) {
        Pattern p = Pattern.compile("[Tt]est");
        return p.matcher(file.getName()).find() || p.matcher(file.getPath()).find();
    }

    private boolean isEndpointSecured(String line, File file) {
        Pattern p = Pattern.compile("^.*endpoint.*https.*$", Pattern.CASE_INSENSITIVE);
        if (!p.matcher(line).matches()) {
            return false;
        }
        return true;
    }

    private boolean isSSLConfigurationSecured(String line, File file) {
        Pattern p = Pattern.compile("^import .*\\.ssl.*;$", Pattern.CASE_INSENSITIVE);
        if (!p.matcher(line).matches()) {
            return false;
        }
        return true;
    }

    private boolean shouldAddFileAsCandidate(String line, File file) {
        if (file.getName().toLowerCase().contains("websocket")) {
            return true;
        }
        return importPattern.matcher(line).matches();
    }

    public VulnerabilityAnalyser applyFilter(int filter) {
        if (!isFilterApplied(filter)) {
            policyMask |= filter;
        }
        return this;
    }

    private boolean isFilterApplied(int filter) {
        return (policyMask | filter) == policyMask;
    }

    public Results detectVulnerabilities() {
        Map<File, Boolean> resultFiles = new HashMap<>();

        candidateFiles.forEach((file, prop) -> {
            if ((prop ^ policyMask) == 0) {
                resultFiles.put(file, true);
            }
            else {
                resultFiles.put(file, false);
            }
        });

        return new Results(resultFiles);
    }
}
